using ContentUnpacker.Decompressors;
using ContentUnpacker.NDSFS;
using ContentUnpacker.Spritesheets;
using GlobalShared.Tilemaps;
using System.Reflection;

namespace TiledToLB.Core.Processors
{
    public static class UnpackerProcessor
    {
        public static async Task UnpackRomAsync(string romInputFilePath, string workspaceOutputPath, bool overwrite = false, bool silent = true)
        {
            createWorkspaceDirectory(workspaceOutputPath, overwrite, silent);
            unpackResources(workspaceOutputPath);

            // Read the rom file system.
            if (!silent)
                Console.WriteLine("Reading ROM file system");
            using FileStream romFile = File.OpenRead(romInputFilePath);
            NDSFileSystem fileSystem = NDSFileSystem.LoadFromRom(romFile);
            if (!silent)
                Console.WriteLine($"Read ROM file system with {fileSystem.FilesById.Count} files and {fileSystem.DirectoriesById.Count} directories");

            // Load the tilesets from the rom, save the pngs to the templates folder.
            string tilesetsFolderPath = Path.Combine(workspaceOutputPath, CommonProcessor.TemplateTilesetsFolderName);
            await loadTileset(fileSystem, romFile, "KingTileset", tilesetsFolderPath);
            await loadTileset(fileSystem, romFile, "MarsTileset", tilesetsFolderPath);
            await loadTileset(fileSystem, romFile, "PirateTileset", tilesetsFolderPath);
        }

        private static void createWorkspaceDirectory(string templateOutputPath, bool overwrite, bool silent)
        {
            // Create the template directory.
            if (overwrite)
            {
                if (Directory.Exists(templateOutputPath))
                    Directory.Delete(templateOutputPath, true);
                if (!silent)
                    Console.WriteLine($"Deleting existing templates folder at \"{Path.GetFullPath(templateOutputPath)}\"");
            }
            if (!Directory.Exists(templateOutputPath))
            {
                Directory.CreateDirectory(templateOutputPath);
                if (!silent)
                    Console.WriteLine($"Created templates folder at \"{Path.GetFullPath(templateOutputPath)}\"");
            }

            // Create the directory structure.
            Directory.CreateDirectory(Path.Combine(templateOutputPath, CommonProcessor.TemplateMapsFolderName));
            Directory.CreateDirectory(Path.Combine(templateOutputPath, CommonProcessor.TemplateTileBlueprintsFolderName));
            Directory.CreateDirectory(Path.Combine(templateOutputPath, CommonProcessor.TemplateTilesetsFolderName));
            Directory.CreateDirectory(Path.Combine(templateOutputPath, CommonProcessor.OutputFolderName));
        }

        private static void unpackResources(string templateOutputPath)
        {
            // Get the embedded resources.
            IEnumerable<string> templateResources = Assembly.GetExecutingAssembly().GetManifestResourceNames()
                .Where(x => x.Contains(CommonProcessor.TemplateSourceFolderName));

            // Unpack the root embedded resources.
            IEnumerable<string> rootResources = templateResources.Where(x => x[x.LastIndexOf(CommonProcessor.TemplateSourceFolderName)..].Count(y => y == '.') == 2);
            extractResourcesInto(templateOutputPath, CommonProcessor.TemplateSourceFolderName, null, rootResources);

            // Unpack the nested embedded resources into their proper folders.
            extractResourcesInto(templateOutputPath, CommonProcessor.TemplateTilesetsFolderName, CommonProcessor.TemplateTilesetsFolderName, templateResources);
            extractResourcesInto(templateOutputPath, CommonProcessor.TemplateMapsFolderName, CommonProcessor.TemplateMapsFolderName, templateResources);

            // Append any build data to the readme.
            string readmeFilePath = Path.Combine(templateOutputPath, "readme.txt");
            string readmeContent = File.ReadAllText(readmeFilePath);
            File.WriteAllText(readmeFilePath, $"Generated by map tool version {typeof(UnpackerProcessor).Assembly.GetName().Version}\n{readmeContent}");
        }

        private static void extractResourcesInto(string templateOutputPath, string resourceSubName, string? subFolderName, IEnumerable<string> templateResources)
        {
            IEnumerable<string> subResources = templateResources.Where(x => x.Contains(resourceSubName));

            foreach (string tilesetResource in subResources)
            {
                string resourceName = tilesetResource[(tilesetResource.LastIndexOf(resourceSubName) + resourceSubName.Length + 1)..];
                string fileName = string.IsNullOrWhiteSpace(subFolderName)
                    ? Path.Combine(templateOutputPath, resourceName)
                    : Path.Combine(templateOutputPath, subFolderName, resourceName);

                using Stream? resourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(tilesetResource);
                if (resourceStream == null)
                {
                    Console.WriteLine($"Missing resource {resourceName}!");
                    continue;
                }

                using FileStream fileStream = File.Create(fileName);
                for (int i = 0; i < resourceStream.Length; i++)
                    fileStream.WriteByte((byte)resourceStream.ReadByte());
            }
        }

        private static async Task loadTileset(NDSFileSystem fileSystem, Stream romReader, string tilesetName, string tiledTemplateOutputPath, bool silent = true)
        {
            string graphicsName = Path.ChangeExtension(tilesetName, "NCGR");
            NDSFile tilesetGraphics = fileSystem.FilesByPath[graphicsName];
            using Stream graphicsStream = new MemoryStream();
            await LegoDecompressor.Decode(romReader, graphicsStream, tilesetGraphics);

            graphicsStream.Position = 0;
            using NDSTileReader tileReader = NDSTileReader.Load(graphicsStream, false);

            string paletteName = Path.ChangeExtension(tilesetName, "NCLR");
            NDSFile tilesetPalette = fileSystem.FilesByPath[paletteName];
            using Stream paletteStream = new MemoryStream();
            await LegoDecompressor.Decode(romReader, paletteStream, tilesetPalette);
            paletteStream.Position = 0;
            NDSColourPalette colourPalette = NDSColourPalette.Load(paletteStream);

            if (!silent)
                await Console.Out.WriteLineAsync($"Loaded {tilesetName} tileset");

            using SpritesheetWriter spritesheetWriter = new((byte)tileReader.Width, (byte)tileReader.Height);
            for (ushort i = 0; i < tileReader.TileCount; i++)
                spritesheetWriter.WriteTileFromReader(tileReader, colourPalette, i);
            string tilesetFilePath = await spritesheetWriter.SaveAsync(tiledTemplateOutputPath ?? "", tilesetName, true, false);

            if (!silent)
                await Console.Out.WriteLineAsync($"Saved {tilesetName} tileset");

            string blockPaletteName = Path.ChangeExtension(tilesetName[..^2], "tbp");
            NDSFile blockPaletteFile = fileSystem.FilesByPath["BP/" + blockPaletteName];
            using Stream blockPaletteStream = new MemoryStream();
            await LegoDecompressor.Decode(romReader, blockPaletteStream, blockPaletteFile);
            blockPaletteStream.Position = 0;
            TilemapBlockPalette blockPalette = TilemapBlockPalette.LoadFromFile(blockPaletteStream);

            if (!silent)
                await Console.Out.WriteLineAsync($"Loaded {tilesetName} block palette");

            int blockCount = 368;
            byte sizeInTiles = (byte)MathF.Ceiling(MathF.Sqrt(blockCount));
            using SpritesheetWriter blockPaletteWriter = new((byte)(sizeInTiles * 3), (byte)(sizeInTiles * 2));
            blockPaletteWriter.WriteBlockPaletteFromReader(tileReader, colourPalette, blockPalette, blockCount, true);
            await blockPaletteWriter.SaveAsync(tiledTemplateOutputPath ?? "", blockPaletteName, true, false);

            if (!silent)
                await Console.Out.WriteLineAsync($"Saved {tilesetName} block palette");
        }
    }
}
